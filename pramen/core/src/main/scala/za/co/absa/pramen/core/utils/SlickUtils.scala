/*
 * Copyright 2022 ABSA Group Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package za.co.absa.pramen.core.utils

import org.slf4j.LoggerFactory
import slick.jdbc.H2Profile.api._

import java.time.{Duration, Instant}
import scala.util.control.NonFatal

object SlickUtils {
  import za.co.absa.pramen.core.utils.FutureImplicits._

  private val log = LoggerFactory.getLogger(this.getClass)

  /**
    * Synchronously executes a query against a JDBC connection.
    * - Handles exceptions
    * - Logs SQL statements generated by the framework
    * - Measures execution time
    *
    * @param db A database
    * @param query A query
    * @return The result of the query.
    */
  def executeQuery[E, U](db: Database, query: Query[E, U, Seq]): Seq[U] = {
    val action = query.result
    val sql = action.statements.mkString("; ")

    try {
      val start = Instant.now
      val result = db.run(action).execute()
      val finish = Instant.now

      val elapsedTime = TimeUtils.prettyPrintElapsedTimeShort(finish.toEpochMilli - start.toEpochMilli)
      if (Duration.between(start, finish).toMillis > 1000L) {
        log.warn(s"Query execution time: $elapsedTime. SQL: $sql")
      } else {
        log.debug(s"Query execution time: $elapsedTime. SQL: $sql")
      }

      result
    } catch {
      case NonFatal(ex) => throw new RuntimeException(s"Error executing an SQL query: $sql", ex)
    }
  }

  /**
    * Synchronously executes a count query against a JDBC connection.
    * - Handles exceptions
    * - Logs SQL statements generated by the framework
    * - Measures execution time
    *
    * @param db A database
    * @param rep A result of query.length
    * @return The result of the query.
    */
  def executeCount(db: Database, rep: Rep[Int]): Int = {
    val action = rep.result
    val sql = action.statements.mkString("; ")

    try {
      val start = Instant.now
      val result = db.run(action).execute()
      val finish = Instant.now

      val elapsedTime = TimeUtils.prettyPrintElapsedTimeShort(finish.toEpochMilli - start.toEpochMilli)
      if (Duration.between(start, finish).toMillis > 1000L) {
        log.warn(s"Count execution time: $elapsedTime. SQL: $sql")
      } else {
        log.debug(s"Count execution time: $elapsedTime. SQL: $sql")
      }

      result
    } catch {
      case NonFatal(ex) => throw new RuntimeException(s"Error executing an SQL query: $sql", ex)
    }
  }
}
